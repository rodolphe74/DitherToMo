* 6809 assembly program generated by cmoc 0.1.85


	SECTION	code


_dkdrv	IMPORT
_dkbuf	IMPORT
_dktrk	IMPORT
_dksec	IMPORT
_dkopc	IMPORT
_secBuf	IMPORT
_pbuf	IMPORT
_blocks	IMPORT
_curTrk	IMPORT
_curSec	IMPORT
_dkdrv	EXPORT
_dkbuf	EXPORT
_dktrk	EXPORT
_dksec	EXPORT
_dkopc	EXPORT
_secBuf	EXPORT
_pbuf	EXPORT
_blocks	EXPORT
_curTrk	EXPORT
_curSec	EXPORT
___va_arg	IMPORT
_abs	IMPORT
_adddww	IMPORT
_atoi	IMPORT
_atol	IMPORT
_atoui	IMPORT
_atoul	IMPORT
_bsearch	IMPORT
_cmpdww	IMPORT
_delay	IMPORT
_divdwb	IMPORT
_divdww	IMPORT
_divmod16	IMPORT
_divmod8	IMPORT
_dwtoa	IMPORT
_enableCMOCFloatSupport	IMPORT
_exit	IMPORT
_isalnum	IMPORT
_isalpha	IMPORT
_isdigit	IMPORT
_isspace	IMPORT
_itoa10	IMPORT
_labs	IMPORT
_ltoa10	IMPORT
_memchr	IMPORT
_memcmp	IMPORT
_memcpy	IMPORT
_memichr	IMPORT
_memicmp	IMPORT
_memmove	IMPORT
_memset	IMPORT
_memset16	IMPORT
_mulwb	IMPORT
_mulww	IMPORT
_printf	IMPORT
_putchar	IMPORT
_putstr	IMPORT
_qsort	IMPORT
_rand	IMPORT
_readline	IMPORT
_readword	IMPORT
_sbrk	IMPORT
_sbrkmax	IMPORT
_setConsoleOutHook	IMPORT
_set_null_ptr_handler	IMPORT
_set_stack_overflow_handler	IMPORT
_sprintf	IMPORT
_sqrt16	IMPORT
_sqrt32	IMPORT
_srand	IMPORT
_strcat	IMPORT
_strchr	IMPORT
_strcmp	IMPORT
_strcpy	IMPORT
_stricmp	IMPORT
_strlen	IMPORT
_strlwr	IMPORT
_strncmp	IMPORT
_strncpy	IMPORT
_strstr	IMPORT
_strtol	IMPORT
_strtoul	IMPORT
_strupr	IMPORT
_subdww	IMPORT
_tolower	IMPORT
_toupper	IMPORT
_ultoa10	IMPORT
_utoa10	IMPORT
_vprintf	IMPORT
_vsprintf	IMPORT
_zerodw	IMPORT
_readSector	EXPORT


*******************************************************************************

* FUNCTION readSector(): defined at tofloppy.c:21
_readSector	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-2,S
* Formal parameter(s):
*      4,U:    2 bytes: trk: unsigned int
*      7,U:    1 byte : sec: unsigned char
* Local non-static variable(s):
*     -2,U:    2 bytes: pSecBuf: int *
* Line tofloppy.c:23: init of variable pSecBuf
	LEAX	_secBuf+0,PCR	index 0 in array secBuf[]
	TFR	X,D		address-of operator
* Emitted no code to cast `unsigned char *' to `int *'
	STD	-2,U		variable pSecBuf
* Line tofloppy.c:24: inline assembly
* Inline assembly:



        LDA #$00
        STA >0x6049


        LDD 4,U
        STD >0x604a


        LDA 7,U
        STA >0x604c


        LDD -2,U
        STD >0x604f

        LDA #$02
        JSR 0xe82a
    

* End of inline assembly.
* Line tofloppy.c:44: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	4,U
	STD	_curTrk+0,PCR
* Line tofloppy.c:45: assignment: =
	LDB	7,U		variable `sec', declared at tofloppy.c:21
	STB	_curSec+0,PCR
* Useless label L00075 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION readSector(): defined at tofloppy.c:21
funcend_readSector	EQU *
funcsize_readSector	EQU	funcend_readSector-_readSector
_compareLong	EXPORT


*******************************************************************************

* FUNCTION compareLong(): defined at tofloppy.c:52
_compareLong	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-32,S
* Formal parameter(s):
*      4,U:    4 bytes: a: long
*      8,U:    4 bytes: b: long
* Local non-static variable(s):
*    -32,U:    2 bytes: la: unsigned int
*    -30,U:    2 bytes: lb: unsigned int
*    -28,U:    2 bytes: ra: unsigned int
*    -26,U:    2 bytes: rb: unsigned int
*    -24,U:    4 bytes: $V00083: long
*    -20,U:    4 bytes: $V00084: long
*    -16,U:    4 bytes: $V00085: long
*    -12,U:    4 bytes: $V00086: long
*     -8,U:    4 bytes: $V00087: long
*     -4,U:    4 bytes: $V00088: long
* Line tofloppy.c:54: init of variable la
	CLRA
	LDB	#$10		decimal 16 signed
	LDA	#$FF		request sign extension
	PSHS	B,A		A=sign/zero ext flag, B=number of bits to shift
	LEAY	D00102,PCR	optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	4,U		variable `a', declared at tofloppy.c:52
	PSHS	Y,X		optim: optimizePshsOps
	LEAX	-20,U		temporary destination, type long
	LBSR	andDWordDWord	preserves X
	LEAS	4,S
	PSHS	X		address of input dword to be shifted
	LEAX	-24,U		temporary destination, type long
	LBSR	rightShiftDWord	preserves X
	LEAS	4,S
	LDD	2,X		init word from low word of long
	STD	-32,U		variable la
* Line tofloppy.c:55: init of variable lb
	CLRA
	LDB	#$10		decimal 16 signed
	LDA	#$FF		request sign extension
	PSHS	B,A		A=sign/zero ext flag, B=number of bits to shift
	LEAY	D00102,PCR	optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	8,U		variable `b', declared at tofloppy.c:52
	PSHS	Y,X		optim: optimizePshsOps
	LEAX	-12,U		temporary destination, type long
	LBSR	andDWordDWord	preserves X
	LEAS	4,S
	PSHS	X		address of input dword to be shifted
	LEAX	-16,U		temporary destination, type long
	LBSR	rightShiftDWord	preserves X
	LEAS	4,S
	LDD	2,X		init word from low word of long
	STD	-30,U		variable lb
* Line tofloppy.c:56: init of variable ra
	LDD	#$FFFF		decimal 65535 unsigned
	PSHS	B,A
	LEAX	4,U		variable `a', declared at tofloppy.c:52
	PSHS	X
	LEAX	-8,U		temporary destination, type long
	LBSR	andDWordWord	preserves X
	LEAS	4,S
	LDD	2,X		init word from low word of long
	STD	-28,U		variable ra
* Line tofloppy.c:57: init of variable rb
	LDD	#$FFFF		decimal 65535 unsigned
	PSHS	B,A
	LEAX	8,U		variable `b', declared at tofloppy.c:52
	PSHS	X
	LEAX	-4,U		temporary destination, type long
	LBSR	andDWordWord	preserves X
	LEAS	4,S
	LDD	2,X		init word from low word of long
	STD	-26,U		variable rb
* Line tofloppy.c:59: if
	LDD	-32,U		variable la
	CMPD	-30,U		variable lb
	BLS	L00104		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00103 removed
* Line tofloppy.c:59
	LDB	#1
	BRA	L00076		return (tofloppy.c:59)
L00104	EQU	*		else clause of if() started at tofloppy.c:59
* Useless label L00105 removed
* Line tofloppy.c:60: if
	LDD	-30,U		variable lb
	CMPD	-32,U		variable la
	BLS	L00107		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00106 removed
* Line tofloppy.c:60
	LDB	#255
	BRA	L00076		return (tofloppy.c:60)
L00107	EQU	*		else clause of if() started at tofloppy.c:60
* Useless label L00108 removed
* Line tofloppy.c:61: if
	LDD	-32,U		variable la
	CMPD	-30,U		variable lb
	BNE	L00110		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00111 removed
	LDD	-28,U		variable ra
	CMPD	-26,U		variable rb
	BLS	L00110		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00109 removed
* Line tofloppy.c:61
	LDB	#1
	BRA	L00076		return (tofloppy.c:61)
L00110	EQU	*		else clause of if() started at tofloppy.c:61
* Useless label L00112 removed
* Line tofloppy.c:62: if
	LDD	-32,U		variable la
	CMPD	-30,U		variable lb
	BNE	L00114		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00115 removed
	LDD	-28,U		variable ra
	CMPD	-26,U		variable rb
	BHS	L00114		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00113 removed
* Line tofloppy.c:62
	LDB	#255
	BRA	L00076		return (tofloppy.c:62)
L00114	EQU	*		else clause of if() started at tofloppy.c:62
* Useless label L00116 removed
* Line tofloppy.c:63: if
	LDD	-32,U		variable la
	CMPD	-30,U		variable lb
	BNE	L00118		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00119 removed
	LDD	-28,U		variable ra
	CMPD	-26,U		variable rb
	BNE	L00118		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00117 removed
* Line tofloppy.c:63
	CLRB
	BRA	L00076		return (tofloppy.c:63)
L00118	EQU	*		else clause of if() started at tofloppy.c:63
* Useless label L00120 removed
L00076	EQU	*		end of compareLong()
	LEAS	,U
	PULS	U,PC
* END FUNCTION compareLong(): defined at tofloppy.c:52
funcend_compareLong	EQU *
funcsize_compareLong	EQU	funcend_compareLong-_compareLong
_seekFat	EXPORT


*******************************************************************************

* FUNCTION seekFat(): defined at tofloppy.c:67
_seekFat	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-17,S
* Formal parameter(s):
*      4,U:    2 bytes: f: struct FILE_STRUCT *
*      6,U:    4 bytes: fileByte: long
*     10,U:    2 bytes: sf: struct SEEK_FAT_STRUCT *
* Local non-static variable(s):
*    -17,U:    1 byte : blkIdx: unsigned char
*    -16,U:    1 byte : blk: unsigned char
*    -15,U:    1 byte : trk: unsigned char
*    -14,U:    1 byte : sec: unsigned char
*    -13,U:    1 byte : forw: unsigned char
*    -12,U:    4 bytes: $V00089: long
*     -8,U:    4 bytes: $V00090: long
*     -4,U:    4 bytes: $V00091: long
* Line tofloppy.c:80: if
* Line tofloppy.c:80: function call: compareLong()
	LDX	4,U		variable f
	LEAX	175,X		member size of FILE_STRUCT
	LEAS	-4,S		pass long by value
	LBSR	push4ByteStruct	argument 2 of compareLong(): long
	LEAX	6,U		variable `fileByte', declared at tofloppy.c:67
	LEAS	-4,S		pass long by value
	LBSR	push4ByteStruct	argument 1 of compareLong(): long
	LBSR	_compareLong
	LEAS	8,S
	CMPB	#0
	BLE	L00122		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00121 removed
* Line tofloppy.c:81
* Line tofloppy.c:81: return with value
	LDD	#$FFFF		constant expression: 65535 decimal, signed
	LBRA	L00077		return (tofloppy.c:81)
L00122	EQU	*		else clause of if() started at tofloppy.c:80
* Useless label L00123 removed
* Line tofloppy.c:84: init of variable blkIdx
	LEAX	D00124,PCR	32-bit constant: 2040
	PSHS	X
	LEAY	6,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LEAX	-12,U		destination of type long
	PSHS	X		address of quotient to be computed
	LDB	#$3F		flag byte
	LBSR	signedDivOrModOnDWord
	LEAS	6,S
	TFR	X,D		cast to `unsigned char': address of source number in D
	LEAS	-1,S		result of cast
	LEAX	,S
	LBSR	initByteFromDWord
	PULS	B		result of cast
	STB	-17,U		variable blkIdx
* Line tofloppy.c:85: init of variable blk
* optim: storeLoad
	CLRA			extend byte index expression
	PSHS	B,A		preserve array index
	LDX	4,U		variable f
	LEAX	11,X		member blocks of FILE_STRUCT
	TFR	X,D
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,X		get r-value
	STB	-16,U		variable blk
* Line tofloppy.c:86: init of variable trk
* optim: storeLoad
	LSRB
	STB	-15,U		variable trk
* Line tofloppy.c:87: init of variable sec
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A
	LEAX	D00124,PCR	32-bit constant: 2040
	PSHS	X
	LEAY	6,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LEAX	-8,U		destination of type long
	PSHS	X		address of quotient to be computed
	LDB	#$3E		flag byte
	LBSR	signedDivOrModOnDWord
	LEAS	6,S
	TFR	X,D		cast to `unsigned int': address of source number in D
	LEAS	-2,S		result of cast
	LEAX	,S
	LBSR	initWordFromDWord
	PULS	A,B		result of cast
	TFR	D,X		optim: stripExtraPulsX
	CLRA
	LDB	#$FF		decimal 255 signed
* optim: stripExtraPulsX
	LBSR	DIV16
	TFR	X,D		quotient
	ADDD	,S++
* Cast from `unsigned int' to byte: result already in B
	STB	-14,U		variable sec
* Line tofloppy.c:88: init of variable forw
	LEAX	D00125,PCR	32-bit constant: 255
	PSHS	X
	LEAY	6,U		optim: transformPshsXPshsX
	PSHS	Y		optim: transformPshsXPshsX
	LEAX	-4,U		destination of type long
	PSHS	X		address of quotient to be computed
	LDB	#$3E		flag byte
	LBSR	signedDivOrModOnDWord
	LEAS	6,S
	TFR	X,D		cast to `unsigned char': address of source number in D
	LEAS	-1,S		result of cast
	LEAX	,S
	LBSR	initByteFromDWord
	PULS	B		result of cast
	STB	-13,U		variable forw
* Line tofloppy.c:90: if
	LDB	-16,U		to be moduloed by 2
	ANDB	#$01		modulo 2
* optim: optimizeAndbTstb
	BEQ	L00127		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00126 removed
* Line tofloppy.c:91
* Line tofloppy.c:91: assignment: +=
	LDB	-14,U		variable sec
	ADDB	#$08		+= operator at tofloppy.c:91
	STB	-14,U
L00127	EQU	*		else clause of if() started at tofloppy.c:90
* Useless label L00128 removed
* Line tofloppy.c:93: assignment: =
* optim: optimize8BitStackOps
* optim: optimize8BitStackOps
* optim: optimizeLdx
	LDB	-16,U		optim: optimize8BitStackOps
	STB	[10,U]		optim: optimizeLdx
* Line tofloppy.c:94: assignment: =
* optim: optimize8BitStackOps
* optim: optimize8BitStackOps
	LDX	10,U		variable sf
* optim: optimizeLeax
	LDB	-15,U		optim: optimize8BitStackOps
	STB	1,X		optim: optimizeLeax
* Line tofloppy.c:95: assignment: =
* optim: optimize8BitStackOps
* optim: optimize8BitStackOps
* optim: removeRepeatedLDX
* optim: optimizeLeax
	LDB	-14,U		optim: optimize8BitStackOps
	STB	2,X		optim: optimizeLeax
* Line tofloppy.c:96: assignment: =
* optim: optimize8BitStackOps
* optim: optimize8BitStackOps
* optim: removeRepeatedLDX
* optim: optimizeLeax
	LDB	-13,U		optim: optimize8BitStackOps
	STB	3,X		optim: optimizeLeax
* Line tofloppy.c:100: return with value
	CLRA
	CLRB
* optim: branchToNextLocation
L00077	EQU	*		end of seekFat()
	LEAS	,U
	PULS	U,PC
* END FUNCTION seekFat(): defined at tofloppy.c:67
funcend_seekFat	EQU *
funcsize_seekFat	EQU	funcend_seekFat-_seekFat
_read	EXPORT


*******************************************************************************

* FUNCTION read(): defined at tofloppy.c:103
_read	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-27,S
* Formal parameter(s):
*      4,U:    2 bytes: f: struct FILE_STRUCT *
*      6,U:    2 bytes: where: unsigned char *
*      8,U:    2 bytes: bytes: unsigned int
* Local non-static variable(s):
*    -27,U:    4 bytes: $V00094: long
*    -23,U:    4 bytes: start: struct SEEK_FAT_STRUCT
*    -19,U:    4 bytes: end: struct SEEK_FAT_STRUCT
*    -15,U:    4 bytes: endIdx: long
*    -11,U:    1 byte : forwToNextSec: unsigned char
*    -10,U:    2 bytes: whereIdx: unsigned int
*     -8,U:    4 bytes: $V00092: long
*     -4,U:    4 bytes: $V00093: long
* Line tofloppy.c:107: function call: seekFat()
	LEAX	-23,U		variable `start', declared at tofloppy.c:105
	PSHS	X		argument 3 of seekFat(): struct SEEK_FAT_STRUCT *
	LDX	4,U		variable f
	LEAX	179,X		member idx of FILE_STRUCT
	LEAS	-4,S		pass long by value
	LBSR	push4ByteStruct	argument 2 of seekFat(): long
	LDD	4,U		variable `f', declared at tofloppy.c:103
	PSHS	B,A		argument 1 of seekFat(): struct FILE_STRUCT *
	LBSR	_seekFat
	LEAS	8,S
* Line tofloppy.c:108: init of variable endIdx
* Push right operand of add.
	LDD	8,U		variable `bytes', declared at tofloppy.c:103
	PSHS	B,A
* Push left operand of add.
	LDX	4,U		variable f
	LEAX	179,X		member idx of FILE_STRUCT
	PSHS	X
	LEAX	-8,U		temporary destination, type long
	LBSR	addDWordUnsignedInt	preserves X
	LEAS	4,S
	TFR	X,D		address of source number
	LEAX	-15,U		variable endIdx
	LBSR	copyDWord
* Line tofloppy.c:110: function call: seekFat()
	LEAX	-19,U		variable `end', declared at tofloppy.c:106
	PSHS	X		argument 3 of seekFat(): struct SEEK_FAT_STRUCT *
* Push right operand of add.
	LDD	8,U		variable `bytes', declared at tofloppy.c:103
	PSHS	B,A
* Push left operand of add.
	LDX	4,U		variable f
	LEAX	179,X		member idx of FILE_STRUCT
	PSHS	X
	LEAX	-4,U		temporary destination, type long
	LBSR	addDWordUnsignedInt	preserves X
	LEAS	4,S
	LEAS	-4,S		pass long by value
	LBSR	push4ByteStruct	argument 2 of seekFat(): long
	LDD	4,U		variable `f', declared at tofloppy.c:103
	PSHS	B,A		argument 1 of seekFat(): struct FILE_STRUCT *
	LBSR	_seekFat
	LEAS	8,S
* Line tofloppy.c:112: function call: readSector()
	LDB	-21,U		member sec of SEEK_FAT_STRUCT, via variable start
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of readSector(): unsigned char
	LDB	-22,U		member trk of SEEK_FAT_STRUCT, via variable start
* optim: stripExtraClrA_B
	PSHS	B,A		argument 1 of readSector(): unsigned char
	LBSR	_readSector
	LEAS	4,S
* Line tofloppy.c:113: init of variable forwToNextSec
	CLR	-11,U		variable forwToNextSec
* Line tofloppy.c:114: init of variable whereIdx
	CLRA
	CLRB
	STD	-10,U		variable whereIdx
* Line tofloppy.c:116: while
	LBRA	L00130		jump to while condition
L00129	EQU	*		while body
* Line tofloppy.c:118: if
* optim: optimize8BitStackOps
* optim: optimize8BitStackOps
	LDB	-22,U		member trk of SEEK_FAT_STRUCT, via variable start
	CMPB	-18,U		optim: optimize8BitStackOps
	BNE	L00133		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00135 removed
* optim: optimize8BitStackOps
* optim: optimize8BitStackOps
	LDB	-21,U		member sec of SEEK_FAT_STRUCT, via variable start
	CMPB	-17,U		optim: optimize8BitStackOps
	BNE	L00133		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00134 removed
* optim: optimize8BitStackOps
* optim: optimize8BitStackOps
	LDB	-20,U		member forw of SEEK_FAT_STRUCT, via variable start
	CMPB	-16,U		optim: optimize8BitStackOps
	BNE	L00133		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00132 removed
* Line tofloppy.c:118
* Line tofloppy.c:120: assignment: +=
* Push right operand of add.
	LDD	8,U		variable `bytes', declared at tofloppy.c:103
	PSHS	B,A
* Push left operand of add.
	LDX	4,U		variable f
	LEAX	179,X		member idx of FILE_STRUCT
	PSHS	X
	LBSR	addDWordUnsignedInt	preserves X
	LEAS	4,S
	LBRA	L00131		break
L00133	EQU	*		else clause of if() started at tofloppy.c:118
* Useless label L00136 removed
* Line tofloppy.c:125: assignment: =
	LEAX	-20,U		member forw of SEEK_FAT_STRUCT, via variable start
	LDB	,X
	INC	,X
	LDX	_pbuf+0,PCR	pointer pbuf
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	PSHS	B
	LDD	-10,U		variable `whereIdx', declared at tofloppy.c:125
	ADDD	#1
	STD	-10,U
	SUBD	#1		post increment yields initial value
	LDX	6,U		pointer where
	LEAX	D,X		add offset
	LDB	,S+
	STB	,X
* Line tofloppy.c:126: if
	LDD	-10,U		variable whereIdx
	CMPD	8,U		variable bytes
	BLS	L00138		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00137 removed
* Line tofloppy.c:126
* Line tofloppy.c:132: assignment: +=
* Push right operand of add.
	LDD	8,U		variable `bytes', declared at tofloppy.c:103
	PSHS	B,A
* Push left operand of add.
	LDX	4,U		variable f
	LEAX	179,X		member idx of FILE_STRUCT
	PSHS	X
	LBSR	addDWordUnsignedInt	preserves X
	LEAS	4,S
	BRA	L00131		break
L00138	EQU	*		else clause of if() started at tofloppy.c:126
* Useless label L00139 removed
* Line tofloppy.c:151: if
	CLRA
* optim: stripConsecutiveLoadsToSameReg
* PSHS B,A optim: optimizeStackOperations1
	LDB	-20,U		member forw of SEEK_FAT_STRUCT, via variable start
* optim: stripExtraClrA_B
	CMPD	#255		optim: optimizeStackOperations1
	BNE	L00141		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00140 removed
* Line tofloppy.c:151
* Line tofloppy.c:152: function call: seekFat()
	LEAX	-23,U		variable `start', declared at tofloppy.c:105
	PSHS	X		argument 3 of seekFat(): struct SEEK_FAT_STRUCT *
* Push right operand of add.
	LDD	-10,U		variable `whereIdx', declared at tofloppy.c:114
	PSHS	B,A
* Push left operand of add.
	LDX	4,U		variable f
	LEAX	179,X		member idx of FILE_STRUCT
	PSHS	X
	LEAX	-27,U		temporary destination, type long
	LBSR	addDWordUnsignedInt	preserves X
	LEAS	4,S
	LEAS	-4,S		pass long by value
	LBSR	push4ByteStruct	argument 2 of seekFat(): long
	LDD	4,U		variable `f', declared at tofloppy.c:103
	PSHS	B,A		argument 1 of seekFat(): struct FILE_STRUCT *
	LBSR	_seekFat
	LEAS	8,S
* Line tofloppy.c:153: function call: readSector()
	LDB	-21,U		member sec of SEEK_FAT_STRUCT, via variable start
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of readSector(): unsigned char
	LDB	-22,U		member trk of SEEK_FAT_STRUCT, via variable start
* optim: stripExtraClrA_B
	PSHS	B,A		argument 1 of readSector(): unsigned char
	LBSR	_readSector
	LEAS	4,S
L00141	EQU	*		else clause of if() started at tofloppy.c:151
* Useless label L00142 removed
L00130	EQU	*		while condition at tofloppy.c:116
	LBRA	L00129		go to start of while body
L00131	EQU	*		after end of while starting at tofloppy.c:116
* Line tofloppy.c:176: return with value
	LDD	-10,U		variable `whereIdx', declared at tofloppy.c:114
* Emitted no code to cast `unsigned int' to `int'
* optim: branchToNextLocation
* Useless label L00078 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION read(): defined at tofloppy.c:103
funcend_read	EQU *
funcsize_read	EQU	funcend_read-_read
_feedBlocks	EXPORT


*******************************************************************************

* FUNCTION feedBlocks(): defined at tofloppy.c:181
_feedBlocks	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-30,S
* Formal parameter(s):
*      4,U:    2 bytes: f: struct FILE_STRUCT *
* Local non-static variable(s):
*    -30,U:    1 byte : blockCount: unsigned char
*    -29,U:    1 byte : nextBlock: unsigned char
*    -28,U:    4 bytes: $V00095: long
*    -24,U:    4 bytes: $V00096: long
*    -20,U:    4 bytes: $V00097: long
*    -16,U:    4 bytes: $V00098: long
*    -12,U:    4 bytes: $V00099: long
*     -8,U:    4 bytes: $V00100: long
*     -4,U:    4 bytes: $V00101: long
* Line tofloppy.c:193: init of variable blockCount
	CLR	-30,U		variable blockCount
* Line tofloppy.c:194: init of variable nextBlock
	LDX	4,U		variable f
	LEAX	11,X		member blocks of FILE_STRUCT
	TFR	X,D
* optim: stripConsecOppositeTFRs
	LDB	,X		get r-value
	STB	-29,U		variable nextBlock
* Line tofloppy.c:195: while
	BRA	L00144		jump to while condition
L00143	EQU	*		while body
* Line tofloppy.c:196: assignment: =
	LDB	-29,U		variable nextBlock
	ADDB	#$01		1
	LEAX	_blocks+0,PCR	address of array blocks
	ABX			add unsigned 8-bit offset
	LDB	,X		get r-value
	STB	-29,U
* Line tofloppy.c:197: post-increment
	INC	-30,U
* Line tofloppy.c:198: assignment: =
	LDB	-29,U		variable `nextBlock', declared at tofloppy.c:194
	PSHS	B
	LDB	-30,U		variable blockCount
	CLRA			extend byte index expression
	PSHS	B,A		preserve array index
	LDX	4,U		variable f
	LEAX	11,X		member blocks of FILE_STRUCT
	TFR	X,D
	ADDD	,S++		add stacked array index to array address in D
	TFR	D,X		put resulting address in X
	LDB	,S+
	STB	,X
L00144	EQU	*		while condition at tofloppy.c:195
	LDB	-29,U		variable nextBlock
	CMPB	#$BF
	BLS	L00143
* optim: branchToNextLocation
* Useless label L00145 removed
* Line tofloppy.c:200: if
* optim: removeLoadInComparisonWithTwoValues
	CMPB	#$C1
	BLO	L00147		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00148 removed
	LDB	-29,U		variable nextBlock
	CMPB	#$C8
	BHI	L00147		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00146 removed
* Line tofloppy.c:200
* Line tofloppy.c:202: assignment: =
	LDB	-29,U		variable nextBlock
	ANDB	#$0F
* optim: stripExtraPushPullB
	LDX	4,U		variable f
* optim: optimizeLeax
* optim: stripExtraPushPullB
	STB	172,X		optim: optimizeLeax
L00147	EQU	*		else clause of if() started at tofloppy.c:200
* Useless label L00149 removed
* Line tofloppy.c:205: assignment: =
* Push right operand of add.
	LDX	4,U		variable f
	LDD	173,X		member trkBytes of FILE_STRUCT
	LEAX	-4,U		destination of cast
	LBSR	initDWordFromUnsignedWord
	PSHS	X
* Push left operand of add.
* Push right operand of add.
* Push right operand of mul.
	CLRA
	LDB	#$FF		decimal 255 signed
	PSHS	B,A
* Push left operand of mul.
* optim: stripExtraClrA_B
	LDB	#$01		decimal 1 signed
	PSHS	B		optim: stripPushLeas
	LDX	4,U		variable f
	LDB	172,X		member lastSectors of FILE_STRUCT
* optim: removeClr
* optim: stripPushLeas1
	SUBB	,S+
* optim: stripExtraClrA_B
	LEAX	-8,U		destination of cast
	LBSR	initDWordFromUnsignedWord
	PSHS	X
	LEAX	-12,U		temporary destination, type long
	LBSR	mulDWordInt	preserves X
	LEAS	4,S
	PSHS	X
* Push left operand of add.
* Push right operand of mul.
	LDD	#$07F8		decimal 2040 signed
	PSHS	B,A
* Push left operand of mul.
	LDB	-30,U		variable blockCount
	ADDB	#$FF		255
	CLRA			promote to word
	LEAX	-16,U		destination of cast
	LBSR	initDWordFromUnsignedWord
	PSHS	X
	LEAX	-20,U		temporary destination, type long
	LBSR	mulDWordInt	preserves X
	LEAS	4,S
	PSHS	X
	LEAX	-24,U		temporary destination, type long
	LBSR	addDWordDWord	preserves X
	LEAS	4,S
	PSHS	X
	LEAX	-28,U		temporary destination, type long
	LBSR	addDWordDWord	preserves X
	LEAS	4,S
	PSHS	X		source struct
	LDX	4,U		variable f
	LEAX	175,X		member size of FILE_STRUCT
	PULS	A,B		source struct
	LBSR	copyDWord	copy 4-byte struct (preserves X)
* Line tofloppy.c:206: assignment: =
	LDB	-30,U		variable `blockCount', declared at tofloppy.c:193
* optim: stripExtraPushPullB
	LDX	4,U		variable f
* optim: optimizeLeax
* optim: stripExtraPushPullB
	STB	171,X		optim: optimizeLeax
* Useless label L00079 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION feedBlocks(): defined at tofloppy.c:181
funcend_feedBlocks	EQU *
funcsize_feedBlocks	EQU	funcend_feedBlocks-_feedBlocks
_readBlocks	EXPORT


*******************************************************************************

* FUNCTION readBlocks(): defined at tofloppy.c:209
_readBlocks	EQU	*
* Calling convention: Default
* Line tofloppy.c:211: function call: readSector()
	CLRA
	LDB	#$02		decimal 2 signed
	PSHS	B,A		argument 2 of readSector(): int
* optim: stripExtraClrA_B
	LDB	#$14		decimal 20 signed
	PSHS	B,A		argument 1 of readSector(): int
	LBSR	_readSector
	LEAS	4,S
* Line tofloppy.c:212: function call: memcpy()
	LDX	#$0100		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	_pbuf+0,PCR	variable `pbuf', declared at tofloppy.c:14
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	_blocks+0,PCR	address of array blocks
	PSHS	X		argument 1 of memcpy(): unsigned char[]
	LBSR	_memcpy
	LEAS	6,S
* Useless label L00080 removed
	RTS
* END FUNCTION readBlocks(): defined at tofloppy.c:209
funcend_readBlocks	EQU *
funcsize_readBlocks	EQU	funcend_readBlocks-_readBlocks
_seekFile	EXPORT


*******************************************************************************

* FUNCTION seekFile(): defined at tofloppy.c:216
_seekFile	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-3,S
* Formal parameter(s):
*      4,U:    2 bytes: name: const char *
*      6,U:    2 bytes: ext: const char *
*      8,U:    2 bytes: f: struct FILE_STRUCT *
* Local non-static variable(s):
*     -3,U:    2 bytes: j: int
*     -1,U:    1 byte : i: unsigned char
* Line tofloppy.c:222: assignment: =
	CLRA
	CLRB
	PSHS	B,A		preserve right side of assignment
	LDX	8,U		variable f
	LEAX	179,X		member idx of FILE_STRUCT
	PULS	A,B		restore right side of assignment
	LBSR	initDWordFromSignedWord
* Line tofloppy.c:223: for init
* Line tofloppy.c:223: init of variable i
	LDB	#$03		3
	STB	-1,U		variable i
	LBRA	L00151		jump to for condition
L00150	EQU	*
* Line tofloppy.c:223: for body
* Line tofloppy.c:224: function call: readSector()
	LDB	-1,U		variable `i', declared at tofloppy.c:223
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of readSector(): unsigned char
	LDB	#$14		optim: changeLoadDToLoadB
	PSHS	B,A		argument 1 of readSector(): int
	LBSR	_readSector
	LEAS	4,S
* Line tofloppy.c:230: for init
* Line tofloppy.c:230: init of variable j
	CLRA
	CLRB
	STD	-3,U		variable j
	LBRA	L00155		jump to for condition
L00154	EQU	*
* Line tofloppy.c:230: for body
* Line tofloppy.c:231: if
* optim: optimizeStackOperations5
* optim: optimizeStackOperations5
* optim: optimizeStackOperations5
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	_pbuf+0,PCR	variable `pbuf', declared at tofloppy.c:14
	ADDD	-3,U		optim: optimizeStackOperations4
	TFR	D,X
	LDB	,X		indirection
	CLRA			promotion of binary operand
	CMPD	#$FF		optim: optimizeStackOperations5
	LBEQ	L00159		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00158 removed
* Line tofloppy.c:231
* Line tofloppy.c:233: if
* Line tofloppy.c:232: function call: strncmp()
* Line tofloppy.c:232: function call: strlen()
	LDD	4,U		variable `name', declared at tofloppy.c:216
	PSHS	B,A		argument 1 of strlen(): const char *
	LBSR	_strlen
	LEAS	2,S
	PSHS	B,A		argument 3 of strncmp(): unsigned int
	LDD	4,U		variable `name', declared at tofloppy.c:216
	PSHS	B,A		argument 2 of strncmp(): const char *
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	_pbuf+0,PCR	variable `pbuf', declared at tofloppy.c:14
	ADDD	-3,U		optim: optimizeStackOperations4
* Emitted no code to cast `unsigned char *' to `const char *'
	PSHS	B,A		argument 1 of strncmp(): const char *
	LBSR	_strncmp
	LEAS	6,S
	ADDD	#0
	LBNE	L00161		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00162 removed
* Line tofloppy.c:233: function call: strncmp()
* Line tofloppy.c:233: function call: strlen()
	LDD	6,U		variable `ext', declared at tofloppy.c:216
	PSHS	B,A		argument 1 of strlen(): const char *
	LBSR	_strlen
	LEAS	2,S
	PSHS	B,A		argument 3 of strncmp(): unsigned int
	LDD	6,U		variable `ext', declared at tofloppy.c:216
	PSHS	B,A		argument 2 of strncmp(): const char *
* optim: optimizeStackOperations5
* optim: optimizeStackOperations5
* optim: optimizeStackOperations5
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	_pbuf+0,PCR	variable `pbuf', declared at tofloppy.c:14
	ADDD	-3,U		optim: optimizeStackOperations4
	ADDD	#$08		optim: optimizeStackOperations5
* Emitted no code to cast `unsigned char *' to `const char *'
	PSHS	B,A		argument 1 of strncmp(): const char *
	LBSR	_strncmp
	LEAS	6,S
	ADDD	#0
	LBNE	L00161		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00160 removed
* Line tofloppy.c:233
* Line tofloppy.c:234: assignment: =
* optim: optimizeStackOperations5
* optim: optimizeStackOperations5
* optim: optimizeStackOperations5
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	_pbuf+0,PCR	variable `pbuf', declared at tofloppy.c:14
	ADDD	-3,U		optim: optimizeStackOperations4
	ADDD	#$0D		optim: optimizeStackOperations5
	TFR	D,X
	LDB	,X		indirection
	PSHS	B
	LDX	8,U		variable f
	LEAX	11,X		member blocks of FILE_STRUCT
	TFR	X,D
* optim: stripConsecOppositeTFRs
	LDB	,S+
	STB	,X
* Line tofloppy.c:235: assignment: =
* optim: optimizeStackOperations5
* optim: optimizeStackOperations5
* optim: optimizeStackOperations5
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	_pbuf+0,PCR	variable `pbuf', declared at tofloppy.c:14
	ADDD	-3,U		optim: optimizeStackOperations4
	ADDD	#$0F		optim: optimizeStackOperations5
	TFR	D,X
	LDB	,X		indirection
	CLRA			promotion of binary operand
	PSHS	B,A
	LDB	#$0E		optim: changeLoadDToLoadB
	PSHS	B,A
* optim: optimizeStackOperations4
* optim: optimizeStackOperations4
	LDD	_pbuf+0,PCR	variable `pbuf', declared at tofloppy.c:14
	ADDD	-3,U		optim: optimizeStackOperations4
	ADDD	,S++
	TFR	D,X
	LDB	,X		indirection
	CLRA			promotion of binary operand
	TFR	D,X		optim: stripExtraPulsX
	LDD	#$0100		decimal 256 signed
* optim: stripExtraPulsX
	LBSR	MUL16
	ADDD	,S++
	PSHS	B,A
	LDX	8,U		variable f
	LEAX	173,X		member trkBytes of FILE_STRUCT
	PULS	A,B		retrieve value to store
	STD	,X
* Line tofloppy.c:236: function call: feedBlocks()
	LDD	8,U		variable `f', declared at tofloppy.c:216
	PSHS	B,A		argument 1 of feedBlocks(): struct FILE_STRUCT *
	LBSR	_feedBlocks
	LEAS	2,S
* Line tofloppy.c:237: function call: memset()
	LDX	#$08		optim: transformPshsDPshsD
* optim: optimizePshsOps
	CLRA
	LDB	#$20		decimal 32 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LDX	8,U		variable f
	LEAX	,X		member name of FILE_STRUCT
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LBSR	_memset
	LEAS	6,S
* Line tofloppy.c:238: function call: strncpy()
* Line tofloppy.c:238: function call: strlen()
	LDD	4,U		variable `name', declared at tofloppy.c:216
	PSHS	B,A		argument 1 of strlen(): const char *
	LBSR	_strlen
	LEAS	2,S
	PSHS	B,A		argument 3 of strncpy(): unsigned int
	LDD	4,U		variable `name', declared at tofloppy.c:216
	PSHS	B,A		argument 2 of strncpy(): const char *
	LDX	8,U		variable f
	LEAX	,X		member name of FILE_STRUCT
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LBSR	_strncpy
	LEAS	6,S
* Line tofloppy.c:239: function call: memset()
	LDX	#$03		optim: transformPshsDPshsD
* optim: optimizePshsOps
	CLRA
	LDB	#$20		decimal 32 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LDX	8,U		variable f
	LEAX	8,X		member ext of FILE_STRUCT
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LBSR	_memset
	LEAS	6,S
* Line tofloppy.c:240: function call: strncpy()
* Line tofloppy.c:240: function call: strlen()
	LDD	6,U		variable `ext', declared at tofloppy.c:216
	PSHS	B,A		argument 1 of strlen(): const char *
	LBSR	_strlen
	LEAS	2,S
	PSHS	B,A		argument 3 of strncpy(): unsigned int
	LDD	6,U		variable `ext', declared at tofloppy.c:216
	PSHS	B,A		argument 2 of strncpy(): const char *
	LDX	8,U		variable f
	LEAX	8,X		member ext of FILE_STRUCT
	PSHS	X		optim: optimizeTfrPush
* optim: optimizeTfrPush
	LBSR	_strncpy
	LEAS	6,S
	BRA	L00081		return (tofloppy.c:241)
L00161	EQU	*		else clause of if() started at tofloppy.c:233
* Useless label L00163 removed
L00159	EQU	*		else clause of if() started at tofloppy.c:231
* Useless label L00164 removed
* Useless label L00156 removed
* Line tofloppy.c:230: for increment(s)
* Line tofloppy.c:230: assignment: +=
	LDD	-3,U		variable j
	ADDD	#$20		+= operator at tofloppy.c:230
	STD	-3,U
L00155	EQU	*
* Line tofloppy.c:230: for condition
	LDD	-3,U		variable j
	CMPD	#$0100
	LBLT	L00154
* optim: branchToNextLocation
* Useless label L00157 removed
* Useless label L00152 removed
* Line tofloppy.c:223: for increment(s)
	INC	-1,U
L00151	EQU	*
* Line tofloppy.c:223: for condition
	LDB	-1,U		variable i
	CMPB	#$10
	LBLS	L00150
* optim: branchToNextLocation
* Useless label L00153 removed
L00081	EQU	*		end of seekFile()
	LEAS	,U
	PULS	U,PC
* END FUNCTION seekFile(): defined at tofloppy.c:216
funcend_seekFile	EQU *
funcsize_seekFile	EQU	funcend_seekFile-_seekFile
_init	EXPORT


*******************************************************************************

* FUNCTION init(): defined at tofloppy.c:248
_init	EQU	*
* Calling convention: Default
* Line tofloppy.c:250: assignment: =
	LEAX	_secBuf+0,PCR	address of array `secBuf`
	TFR	X,D		as r-value
* Emitted no code to cast `unsigned char[]' to `unsigned char *'
	STD	_pbuf+0,PCR
* Line tofloppy.c:251: assignment: =
	CLRA
	CLRB
	STD	_curTrk+0,PCR
* Line tofloppy.c:252: assignment: =
	CLR	_curSec+0,PCR	variable curSec
* Line tofloppy.c:253: function call: readBlocks()
	LBSR	_readBlocks
* Useless label L00082 removed
	RTS
* END FUNCTION init(): defined at tofloppy.c:248
funcend_init	EQU *
funcsize_init	EQU	funcend_init-_init


	ENDSECTION




	SECTION	initgl




*******************************************************************************

* Initialize global variables.


	ENDSECTION




	SECTION	rodata


string_literals_start	EQU	*
string_literals_end	EQU	*
dword_constants_start	EQU	*


*******************************************************************************

* DWORD CONSTANTS
D00102	EQU	*
	FCB	$FF,$FF,$00,$00
D00124	EQU	*
	FCB	$00,$00,$07,$F8
D00125	EQU	*
	FCB	$00,$00,$00,$FF
dword_constants_end	EQU	*


*******************************************************************************

* READ-ONLY GLOBAL VARIABLES


	ENDSECTION




	SECTION	rwdata


* Statically-initialized global variables
_dkdrv	EQU	*		dkdrv: unsigned char *
	FDB	$6049		24649 decimal
_dkbuf	EQU	*		dkbuf: int *
	FDB	$604F		24655 decimal
_dktrk	EQU	*		dktrk: int *
	FDB	$604A		24650 decimal
_dksec	EQU	*		dksec: unsigned char *
	FDB	$604C		24652 decimal
_dkopc	EQU	*		dkopc: unsigned char *
	FDB	$6048		24648 decimal
* Statically-initialized local static variables


	ENDSECTION




	SECTION	bss


bss_start	EQU	*
* Uninitialized global variables
_secBuf	EQU	*
	RMB	256		secBuf
_pbuf	EQU	*
	RMB	2		pbuf
_blocks	EQU	*
	RMB	256		blocks
_curTrk	EQU	*
	RMB	2		curTrk
_curSec	EQU	*
	RMB	1		curSec
* Uninitialized local static variables
bss_end	EQU	*


	ENDSECTION




*******************************************************************************

* Importing 20 utility routine(s).
DIV16	IMPORT
MUL16	IMPORT
_memcpy	IMPORT
_memset	IMPORT
_strlen	IMPORT
_strncmp	IMPORT
_strncpy	IMPORT
addDWordDWord	IMPORT
addDWordUnsignedInt	IMPORT
andDWordDWord	IMPORT
andDWordWord	IMPORT
copyDWord	IMPORT
initByteFromDWord	IMPORT
initDWordFromSignedWord	IMPORT
initDWordFromUnsignedWord	IMPORT
initWordFromDWord	IMPORT
mulDWordInt	IMPORT
push4ByteStruct	IMPORT
rightShiftDWord	IMPORT
signedDivOrModOnDWord	IMPORT


*******************************************************************************

	END
